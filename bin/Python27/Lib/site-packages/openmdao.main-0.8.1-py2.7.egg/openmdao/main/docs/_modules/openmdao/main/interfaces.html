
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>openmdao.main.interfaces &mdash; OpenMDAO Documentation</title>
    
    <link rel="stylesheet" href="../../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.8.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="OpenMDAO Documentation" href="../../../index.html" />
    <link rel="up" title="Module code" href="../../index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
  <li><a href="http://openmdao.org">OpenMDAO Home</a> &raquo;</li>
  
        <li><a href="../../../index.html">OpenMDAO Documentation v0.8.1</a> &raquo;</li>

          <li><a href="../../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for openmdao.main.interfaces</h1><div class="highlight"><pre>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Interfaces for the OpenMDAO project.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c"># pylint: disable-msg=E0213,E0211,W0232</span>

<span class="kn">from</span> <span class="nn">zope.interface</span> <span class="kn">import</span> <span class="n">implements</span><span class="p">,</span> <span class="n">classImplements</span><span class="p">,</span> <span class="n">Attribute</span><span class="p">,</span> <span class="n">Interface</span>

<span class="kn">from</span> <span class="nn">openmdao.main.constants</span> <span class="kn">import</span> <span class="n">SAVE_CPICKLE</span>


<span class="k">class</span> <span class="nc">IArchitecture</span><span class="p">(</span><span class="n">Interface</span><span class="p">):</span>

    <span class="n">parent</span> <span class="o">=</span> <span class="n">Attribute</span><span class="p">(</span><span class="s">&quot;parent Assembly&quot;</span><span class="p">)</span>
    <span class="n">data_recorders</span> <span class="o">=</span> <span class="n">Attribute</span><span class="p">(</span><span class="s">&quot;List of CaseRecorder instances where data from &quot;</span>
                               <span class="s">&quot;the optimization should be stored.&quot;</span><span class="p">)</span>
    <span class="n">param_types</span> <span class="o">=</span> <span class="n">Attribute</span><span class="p">(</span><span class="s">&quot;list of types of allowed parameters.  &quot;</span>
                            <span class="s">&quot;Valid values are: [&#39;continuous&#39;,&#39;discrete&#39;,&#39;enum&#39;]&quot;</span><span class="p">)</span>
    <span class="n">constraint_types</span> <span class="o">=</span> <span class="n">Attribute</span><span class="p">(</span><span class="s">&quot;list of types of allowed constraints. &quot;</span>
                                 <span class="s">&quot; Valid values are: [&#39;eq&#39;, &#39;ineq&#39;]&quot;</span><span class="p">)</span>
    <span class="n">num_allowed_objectives</span> <span class="o">=</span> <span class="n">Attribute</span><span class="p">(</span><span class="s">&quot;number of objectives supported.&quot;</span><span class="p">)</span>
    <span class="n">has_coupling_vars</span> <span class="o">=</span> <span class="n">Attribute</span><span class="p">(</span><span class="s">&quot;True if coupling variables are required.&quot;</span><span class="p">)</span>
    <span class="n">has_global_des_vars</span> <span class="o">=</span> <span class="n">Attribute</span><span class="p">(</span><span class="s">&quot;True if the architecture requires a problem &quot;</span>
                                    <span class="s">&quot;formulation with global design variables in it&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">configure</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;sets up drivers,workflows, and data connections in</span>
<span class="sd">        the assembly to configure the architecture</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">clear</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;removes all the drivers, workflows, and data connections in the</span>
<span class="sd">        assembly, leaving the assembly cleaned up.</span>
<span class="sd">        &quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">IContainer</span><span class="p">(</span><span class="n">Interface</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Interface for an object containing variables and other IContainers.&quot;&quot;&quot;</span>

    <span class="n">parent</span> <span class="o">=</span> <span class="n">Attribute</span><span class="p">(</span><span class="s">&quot;parent of this Container (or None)&quot;</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">Attribute</span><span class="p">(</span><span class="s">&quot;name of this Container&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a Container object to this Container.</span>
<span class="sd">        Returns the added Container object.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">connect</span><span class="p">(</span><span class="n">srcpath</span><span class="p">,</span> <span class="n">destpath</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Connects one source variable to one destination variable.</span>
<span class="sd">        When a pathname begins with &#39;parent.&#39;, that indicates</span>
<span class="sd">        that it is referring to a variable outside of this object&#39;s scope.</span>

<span class="sd">        srcpath: str</span>
<span class="sd">            Pathname of source variable.</span>

<span class="sd">        destpath: str</span>
<span class="sd">            Pathname of destination variable.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">contains</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return True if the child specified by the given dotted path</span>
<span class="sd">        name is contained in this Container.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">disconnect</span><span class="p">(</span><span class="n">srcpath</span><span class="p">,</span> <span class="n">destpath</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Removes the connection between one source variable and one</span>
<span class="sd">        destination variable.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">get_dyn_trait</span><span class="p">(</span><span class="n">pathname</span><span class="p">,</span> <span class="n">iotype</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">trait</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a trait if a trait with the given pathname exists, possibly</span>
<span class="sd">        creating the trait &quot;on-the-fly.&quot; If an attribute exists with the given</span>
<span class="sd">        pathname but no trait is found or can be created, or if pathname</span>
<span class="sd">        references a trait in a parent scope, None will be returned. If no</span>
<span class="sd">        attribute exists with the given pathname within this scope, an</span>
<span class="sd">        AttributeError will be raised.</span>

<span class="sd">        pathname: str</span>
<span class="sd">            Pathname of the desired trait.  May contain dots.</span>

<span class="sd">        iotype: str (optional)</span>
<span class="sd">            Expected iotype of the trait.</span>

<span class="sd">        trait: TraitType (optional)</span>
<span class="sd">            Trait to be used for validation.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the object specified by the given</span>
<span class="sd">        path, which may contain &#39;.&#39; characters.  *index*, if not None,</span>
<span class="sd">        should be a list of container indices and/or tuples following</span>
<span class="sd">        the protocol described in the docs for the</span>
<span class="sd">        openmdao.main.index.process_index_entry() function.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">get_pathname</span><span class="p">(</span><span class="n">rel_to_scope</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return full path name to this container, relative to scope</span>
<span class="sd">        *rel_to_scope*. If *rel_to_scope* is *None*, return the full pathname.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">get_wrapped_attr</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;If the named Variable can return an AttrWrapper, then this</span>
<span class="sd">        function will return that, with the value set to the current value of</span>
<span class="sd">        the variable. Otherwise, it functions like *getattr*, just</span>
<span class="sd">        returning the value of the variable. Raises an exception if the</span>
<span class="sd">        variable cannot be found. The value will be copied if the variable has</span>
<span class="sd">        a &#39;copy&#39; metadata attribute that is not None. Possible values for</span>
<span class="sd">        &#39;copy&#39; are &#39;shallow&#39; and &#39;deep&#39;.  index, if not None, should be of</span>
<span class="sd">        the same form as described in the get() function.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">items</span><span class="p">(</span><span class="n">recurse</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="o">**</span><span class="n">metadata</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a list of tuples of the form (rel_pathname, obj) for each</span>
<span class="sd">        trait of this Container that matches the given metadata. If recurse is</span>
<span class="sd">        True, also iterate through all child Containers of each Container</span>
<span class="sd">        found.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">list_containers</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Return a list of names of child Containers.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">get_metadata</span><span class="p">(</span><span class="n">traitpath</span><span class="p">,</span> <span class="n">metaname</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Retrieve the metadata associated with the trait found using</span>
<span class="sd">        traitpath.  If metaname is None, return the entire metadata dictionary</span>
<span class="sd">        for the specified trait. Otherwise, just return the specified piece</span>
<span class="sd">        of metadata.  If the specified piece of metadata is not part of</span>
<span class="sd">        the trait, None is returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">get_trait</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the trait indicated by name, or None if not found.  No recursive</span>
<span class="sd">        search is performed if name contains dots.  This is a replacement</span>
<span class="sd">        for the trait() method on HasTraits objects, because that method</span>
<span class="sd">        can return traits that shouldn&#39;t exist. Do not use the trait() function</span>
<span class="sd">        unless you are certain that the named trait exists.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">pre_delete</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Perform any required operations before being deleted.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">post_load</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Perform any required operations after model has been loaded.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove the specified child from this container and remove any</span>
<span class="sd">        public trait objects that reference that child. Notify any</span>
<span class="sd">        observers.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">revert_to_defaults</span><span class="p">(</span><span class="n">recurse</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets the values of all of the inputs to their default values.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="n">outstream</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="n">SAVE_CPICKLE</span><span class="p">,</span> <span class="n">proto</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Save the state of this object and its children to the given</span>
<span class="sd">        output stream. Pure Python classes generally won&#39;t need to</span>
<span class="sd">        override this because the base class version will suffice, but</span>
<span class="sd">        Python extension classes will have to override. The format</span>
<span class="sd">        can be supplied in case something other than cPickle is needed.</span>

<span class="sd">        outstream: file or string</span>
<span class="sd">            Stream to save to.</span>

<span class="sd">        fmt: int</span>
<span class="sd">            Format for saved data.</span>

<span class="sd">        proto: int</span>
<span class="sd">            Protocol used.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">src</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the value of the Variable specified by the given path, which</span>
<span class="sd">        may contain &#39;.&#39; characters. The Variable will be set to the given</span>
<span class="sd">        value, subject to validation and constraints. *index*, if not None,</span>
<span class="sd">        should be a list of container indices and/or single entry lists of attribute</span>
<span class="sd">        names.  For example, to get something like comp.x[2][&#39;mykey&#39;].child.value,</span>
<span class="sd">        *index* would look like:  [2,&#39;mykey&#39;,[&#39;child&#39;],[&#39;value&#39;]].  Attribute names</span>
<span class="sd">        are placed in sublists to avoid ambiguity with string container indices.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">cpath_updated</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Called whenever this Container&#39;s position in the Container hierarchy changes.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">configure</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Called once, after this Container has been placed in a rooted Container hierarchy.&quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">IComponent</span><span class="p">(</span><span class="n">IContainer</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Interface for an IContainer object that can be executed to update the values of</span>
<span class="sd">    its output variables based on the values of its input variables.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">check_configuration</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Verify that this component is properly configured to execute.</span>
<span class="sd">        Classes inheriting from Component should not override this function,</span>
<span class="sd">        but instead override check_config().</span>
<span class="sd">        Bad configurations should raise an exception.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="n">force</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Run this object. This should include fetching input variables,</span>
<span class="sd">        executing, and updating output variables. Do not override this function.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">is_valid</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Return False if any of our variables is invalid.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">list_inputs</span><span class="p">(</span><span class="n">valid</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a list of names of input values. If valid is not None,</span>
<span class="sd">        the the list will contain names of inputs with matching validity.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">list_outputs</span><span class="p">(</span><span class="n">valid</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a list of names of output values. If valid is not None,</span>
<span class="sd">        the the list will contain names of outputs with matching validity.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">connect</span><span class="p">(</span><span class="n">srcpath</span><span class="p">,</span> <span class="n">destpath</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Connects one source variable to one destination variable.</span>
<span class="sd">        When a pathname begins with &#39;parent.&#39;, that indicates</span>
<span class="sd">        that it is referring to a variable outside of this object&#39;s scope.</span>

<span class="sd">        srcpath: str</span>
<span class="sd">            Pathname of source variable.</span>

<span class="sd">        destpath: str</span>
<span class="sd">            Pathname of destination variable.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">disconnect</span><span class="p">(</span><span class="n">srcpath</span><span class="p">,</span> <span class="n">destpath</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Removes the connection between one source variable and one</span>
<span class="sd">        destination variable.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">get_expr_depends</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Returns a list of tuples of the form (src_comp_name, dest_comp_name)</span>
<span class="sd">        for each dependency resulting from ExprEvaluators in this Component.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">get_expr_sources</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Return a list of tuples containing the names of all upstream components that are</span>
<span class="sd">        referenced in any of our objectives, along with an initial exec_count of 0.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">get_abs_directory</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Return absolute path of execution directory.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">checkpoint</span><span class="p">(</span><span class="n">outstream</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="n">SAVE_CPICKLE</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Save sufficient information for a restart. By default, this</span>
<span class="sd">        just calls *save()*.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">restart</span><span class="p">(</span><span class="n">instream</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Restore state using a checkpoint file. The checkpoint file is</span>
<span class="sd">        typically a delta from a full saved state file. If checkpoint is</span>
<span class="sd">        overridden, this should also be overridden.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">get_file_vars</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Return list of (filevarname, filevarvalue, file trait) owned by this</span>
<span class="sd">        component.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">step</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;For Components that run other components (e.g., Assembly or Drivers),</span>
<span class="sd">        this will run one Component and return. For simple components, it is</span>
<span class="sd">        the same as *run()*.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">stop</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Stop this component.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">get_valid</span><span class="p">(</span><span class="n">names</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the value of the validity flag for each of the named io traits.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">set_valid</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">valid</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Mark the io traits with the given names as valid or invalid.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">invalidate_deps</span><span class="p">(</span><span class="n">varnames</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Invalidate all of our outputs if they&#39;re not invalid already.</span>
<span class="sd">        For a typical Component, this will always be all or nothing, meaning</span>
<span class="sd">        there will never be partial validation of outputs.  Components</span>
<span class="sd">        supporting partial output validation must override this function.</span>

<span class="sd">        Returns None, indicating that all outputs are invalidated.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">update_outputs</span><span class="p">(</span><span class="n">outnames</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Do what is necessary to make the specified output Variables valid.</span>
<span class="sd">        For a simple Component, this will result in a *run()*.</span>
<span class="sd">        &quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">IDriver</span><span class="p">(</span><span class="n">IComponent</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An interface for objects that manage the iteration of workflows.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">workflow</span> <span class="o">=</span> <span class="n">Attribute</span><span class="p">(</span><span class="s">&quot;object that knows how to run a single iteration over&quot;</span>
                         <span class="s">&quot; this Driver&#39;s iteration set&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">iteration_set</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a set of names (not pathnames) containing all Components</span>
<span class="sd">        in this Driver&#39;s workflow or any of its sub-workflows.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">get_workflow</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get the driver info and the list of components that make up the</span>
<span class="sd">            driver&#39;s workflow; recurse on nested drivers.</span>
<span class="sd">        &quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">ISolver</span><span class="p">(</span><span class="n">IDriver</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An interface for drivers that are solvers.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">pass</span>


<span class="k">class</span> <span class="nc">IOptimizer</span><span class="p">(</span><span class="n">IDriver</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An interface for drivers that are optimizers.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">pass</span>


<span class="k">class</span> <span class="nc">IAssembly</span><span class="p">(</span><span class="n">IComponent</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An interface for objects that contain a driver and its workflow components.&quot;&quot;&quot;</span>

    <span class="n">driver</span> <span class="o">=</span> <span class="n">Attribute</span><span class="p">(</span><span class="s">&quot;object that manage&#39;s the iteration of a workflow&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_dataflow</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get a dictionary of components and the connections between them</span>
<span class="sd">            that make up the data flow for the assembly;</span>
<span class="sd">            also includes parameter, constraint, and objective flows</span>
<span class="sd">        &quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">IFactory</span> <span class="p">(</span><span class="n">Interface</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An object that creates and returns objects based on a type string.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">create</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">typname</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">server</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
               <span class="n">res_desc</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">ctor_args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an object of type *typname,* (or a proxy to it if it resides</span>
<span class="sd">        in another process) using the specified package version, server</span>
<span class="sd">        location, and resource description. Returns None if this factory is</span>
<span class="sd">        unable to create the specified type.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">get_available_types</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">groups</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a list tuples of the form (typename, meta_dict) for all</span>
<span class="sd">        available types based on the given list of entry point groups. If</span>
<span class="sd">        groups is None, all types matching any openmdao entry point group will</span>
<span class="sd">        be returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">get_signature</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">typname</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return constructor argument signature for *typname,* using the</span>
<span class="sd">        specified package version. The return value is a dictionary:</span>

<span class="sd">        args: list</span>
<span class="sd">            List of 1 or 2-element lists. The first element is the argument</span>
<span class="sd">            name, the second element is the default value.</span>

<span class="sd">        varargs: string</span>
<span class="sd">            The name of the &#39;*&#39; argument.</span>

<span class="sd">        kwargs: string</span>
<span class="sd">            The name of the &#39;**&#39; argument.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">cleanup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This function is optional, but if present it will be called by</span>
<span class="sd">        the FactoryManager prior to the factory being removed from the</span>
<span class="sd">        list of active factories.</span>
<span class="sd">        &quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">IResourceAllocator</span> <span class="p">(</span><span class="n">Interface</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An object responsible for allocating CPU/disk resources for a particular</span>
<span class="sd">    host, cluster, load balancer, etc.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">max_servers</span><span class="p">(</span><span class="n">resource_desc</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the maximum number of servers which could be deployed for</span>
<span class="sd">        `resource_desc`.  The value needn&#39;t be exact, but performance may</span>
<span class="sd">        suffer if it overestimates.  The value is used to limit the number</span>
<span class="sd">        of concurrent evaluations.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">time_estimate</span><span class="p">(</span><span class="n">resource_desc</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return `(estimate, criteria)` indicating how well this resource</span>
<span class="sd">        allocator can satisfy the `resource_desc` request.  The estimate will</span>
<span class="sd">        be:</span>

<span class="sd">        - &gt;0 for an estimate of walltime (seconds).</span>
<span class="sd">        -  0 for no estimate.</span>
<span class="sd">        - -1 for no resource at this time.</span>
<span class="sd">        - -2 for no support for `resource_desc`.</span>

<span class="sd">        The returned criteria is a dictionary containing information related</span>
<span class="sd">        to the estimate, such as load averages, unsupported resources, etc.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">deploy</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">resource_desc</span><span class="p">,</span> <span class="n">criteria</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Deploy a server suitable for `resource_desc`.</span>
<span class="sd">        `criteria` is the dictionary returned by :meth:`time_estimate`.</span>
<span class="sd">        Returns a proxy to the deployed server.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">list_allocated_components</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Return a list of tuples `(hostname, pid, component_name)` for each</span>
<span class="sd">        Component currently allocated by this allocator.&quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">ICaseIterator</span><span class="p">(</span><span class="n">Interface</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An iterator that returns Case objects.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Returns an iterator of Cases&quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">ICaseRecorder</span><span class="p">(</span><span class="n">Interface</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A recorder of Cases.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">startup</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Perform any operations required to start-up this recorder.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">record</span><span class="p">(</span><span class="n">case</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Record the given Case.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">get_iterator</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Return an iterator that matches the format that this recorder uses.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">close</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Perform any operations required to shut-down this recorder.&quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">ICaseFilter</span><span class="p">(</span><span class="n">Interface</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Selects cases.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">select</span><span class="p">(</span><span class="n">seqno</span><span class="p">,</span> <span class="n">case</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns True if `case` should be used, where `seqno` is the index</span>
<span class="sd">        of `case` in the sequence of cases.&quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">IDOEgenerator</span><span class="p">(</span><span class="n">Interface</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An iterator that returns lists of normalized values that are mapped</span>
<span class="sd">    to design variables by a Driver.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">num_parameters</span> <span class="o">=</span> <span class="n">Attribute</span><span class="p">(</span><span class="s">&quot;number of parameters in the DOE&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Return an iterator object where each iteration returns</span>
<span class="sd">        a set of values in the range [0., 1.].</span>
<span class="sd">        &quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">IDifferentiator</span><span class="p">(</span><span class="n">Interface</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A plugin to driver that can determine derivatives between a driver&#39;s</span>
<span class="sd">    parameters and its objectives and constraints.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">calc_gradient</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Returns the gradient vectors for this Driver&#39;s workflow&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">calc_hessian</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Returns the Hessian matrix for this Driver&#39;s workflow&quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">IUncertainVariable</span><span class="p">(</span><span class="n">Interface</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A variable which supports uncertainty&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">getvalue</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Returns either value from expected() or from sample() depending on</span>
<span class="sd">        the global or local uncertainty setting.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">expected</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Calculates the expected value of the uncertainty distribution.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">sample</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Generates a random number from an uncertain distribution.&quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">IHasCouplingVars</span><span class="p">(</span><span class="n">Interface</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An interface to support the declaration of coupling variables</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">add_coupling_var</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indep</span><span class="p">,</span> <span class="n">dep</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;adds a new pair (indep/dep) of coupling variables</span>

<span class="sd">        indep: str</span>
<span class="sd">            name of the independent variable, or the variable</span>
<span class="sd">            that should be varied, to meet the coupling constraint</span>
<span class="sd">        dep: str</span>
<span class="sd">            name of the dependent variable, or the variable that</span>
<span class="sd">            needs to be forced to be consistent with the independent</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">remove_coupling_var</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">couple</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;removes the pair (indep/dep) of coupling variables.</span>

<span class="sd">        couple: tuple of str</span>
<span class="sd">            two tuple of (&lt;indep&gt;,&lt;dep&gt;) to be removed</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">list_coupling_vars</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;returns a ordered list of names of the coupling variables&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">clear_coupling_vars</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;removes all coupling variables&quot;&quot;&quot;</span>

<span class="c">#class IHasGlobalDesVars(Interface):</span>
    <span class="c">#&quot;&quot;&quot;Interface for managing global design variables in assemblies</span>

    <span class="c">#parent: Assembly</span>
        <span class="c">#containing assembly where the HasGlobalDesVars lives.</span>
    <span class="c">#&quot;&quot;&quot;</span>

    <span class="c">#def add_global_des_var(name,targets,low,high,scalar=1.0,adder=0.0):</span>
        <span class="c">#&quot;&quot;&quot;adds a global design variable to the assembly</span>

        <span class="c">#name: str</span>
            <span class="c">#name given to the global design variable</span>
        <span class="c">#targets: list of str</span>
            <span class="c">#names of the component variables that this global design variable should link to</span>
        <span class="c">#low: float</span>
            <span class="c">#minimum allowed value for the global design variable</span>
        <span class="c">#high: float</span>
            <span class="c">#maximum allowed value for the global design variable</span>
        <span class="c">#scalar: float (optional)</span>
            <span class="c">#default: 1.0. scalar value which is multiplied by the value of the global design</span>
            <span class="c">#variable before setting target values</span>
        <span class="c">#adder: float (optiona)</span>
            <span class="c">#default: 0.0. amount which is added to the value of the global</span>
            <span class="c">#design variable before setting target values</span>
        <span class="c">#&quot;&quot;&quot;</span>

    <span class="c">#def remove_global_des_var(name):</span>
        <span class="c">#&quot;&quot;&quot;removed the global design variable from the assembly&quot;&quot;&quot;</span>

    <span class="c">#def clear_global_des_vars():</span>
        <span class="c">#&quot;&quot;&quot;removes all global design variables from the assembly&quot;&quot;&quot;</span>

    <span class="c">#def list_global_des_vars():</span>
        <span class="c">#&quot;&quot;&quot;returns a list of all the names of global design variable objects in the assembly&quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">ISurrogate</span><span class="p">(</span><span class="n">Interface</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">get_uncertain_value</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Converts a deterministic value into an uncertain quantity which</span>
<span class="sd">        matches the uncertain variable type the surrogate predicts.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="n">X</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Predicts a value of from the surrogate model for the given independent values in X.</span>

<span class="sd">        X: list</span>
<span class="sd">            The input values for which the predicted output is requested.</span>

<span class="sd">        Returns the predicted output value.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">train</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Trains the surrogate model, based on the given training data set.</span>

<span class="sd">        X: iterator of lists</span>
<span class="sd">            Values representing the training case input history.</span>
<span class="sd">        y: iterator</span>
<span class="sd">            Training case output history for this surrogate&#39;s output,</span>
<span class="sd">            which corresponds to the training case input history given by X.</span>
<span class="sd">        &quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">IHasParameters</span><span class="p">(</span><span class="n">Interface</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">add_parameter</span><span class="p">(</span><span class="n">param_name</span><span class="p">,</span> <span class="n">low</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds a parameter to the driver.</span>

<span class="sd">        param_name: str</span>
<span class="sd">            Name of the parameter to add.</span>
<span class="sd">        low: number (optional)</span>
<span class="sd">            Minimum allowed value the optimzier can use for this parameter. If not specified,</span>
<span class="sd">            then the *low* value from the variable is used.</span>
<span class="sd">        high: number (optional)</span>
<span class="sd">            Maximum allowed value the optimizer can use for this parameter. If not specified,</span>
<span class="sd">            then the *high* value from the variable is used.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">remove_parameter</span><span class="p">(</span><span class="n">param_name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Removes the specified parameter. Raises a KeyError if param_name is not found.</span>

<span class="sd">        param_name: str</span>
<span class="sd">            Name of the parameter to remove.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">list_param_targets</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Lists the targets of all parameters.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">clear_parameters</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Removes all parameters.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">get_parameters</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Returns an ordered dict of parameter objects.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">set_parameters</span><span class="p">(</span><span class="n">X</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Pushes the values in the X input array into the corresponding</span>
<span class="sd">        variables in the model.</span>

<span class="sd">        X: iterator</span>
<span class="sd">            iterator of input values with an order defined to match the order</span>
<span class="sd">            of parameters returned by the get_parameters method. X must support</span>
<span class="sd">             the len() function.</span>
<span class="sd">        &quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">IHasEvents</span><span class="p">(</span><span class="n">Interface</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">add_event</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds an event variable to be set when set_events is called.</span>

<span class="sd">        name: str</span>
<span class="sd">            Name of the event variable that should be set during execution.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">remove_event</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Removes the specified event variable.</span>

<span class="sd">        name: str</span>
<span class="sd">            Name of the event to be removed.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">get_events</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Return the list of event variables to be set.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">clear_events</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Remove all event variables from the list.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">set_events</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Set all events in the event list.&quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">IHasEqConstraints</span><span class="p">(</span><span class="n">Interface</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An Interface for objects containing equality constraints.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">add_constraint</span><span class="p">(</span><span class="n">expr_string</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds an equality constraint.</span>

<span class="sd">        expr_string: str</span>
<span class="sd">            A string containing an assignment, e.g., &#39;a = 2*b+5&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">remove_constraint</span><span class="p">(</span><span class="n">expr_string</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Removes the given constraint.</span>

<span class="sd">        expr_string: str</span>
<span class="sd">            A string matching the constraint to be</span>
<span class="sd">            removed.  Whitespace is ignored when matching.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">clear_constraints</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Removes all constraints.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">get_eq_constraints</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Returns an ordered dictionary of equality constraint objects.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">eval_eq_constraints</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Evaluates the constraint expressions and returns a list of tuples of the</span>
<span class="sd">        form (lhs, rhs, operator, is_violated), where rhs is the right-hand side</span>
<span class="sd">        of the equality, lhs is the left-hand side of the equality, operator is</span>
<span class="sd">        the string &#39;=&#39;, and is_violated is a boolean which is True if the constraint</span>
<span class="sd">        is currently violated.  The operator entry in the tuple is always the same</span>
<span class="sd">        for an equality constraint, but is included for consistency with the</span>
<span class="sd">        eval_ineq_constraints function used for inequality constraints.</span>
<span class="sd">        &quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">IHasIneqConstraints</span><span class="p">(</span><span class="n">Interface</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An Interface for objects containing inequality constraints.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">add_constraint</span><span class="p">(</span><span class="n">expr_string</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds an inequality constraint as a string containing an inequality,</span>
<span class="sd">        for example, &#39;a &gt; b&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">remove_constraint</span><span class="p">(</span><span class="n">expr_string</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Removes the constraint matching the given string. Whitespace is ignored.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">clear_constraints</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Removes all constraints.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">get_ineq_constraints</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Returns an ordered dict of inequality constraint objects.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">eval_ineq_constraints</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Evaluates the constraint expressions and returns a list of tuples of the</span>
<span class="sd">        form (lhs, rhs, relation, is_violated).</span>
<span class="sd">        &quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">IHasConstraints</span><span class="p">(</span><span class="n">IHasEqConstraints</span><span class="p">,</span> <span class="n">IHasIneqConstraints</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An Interface for objects containing both equality and inequality constraints.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">add_constraint</span><span class="p">(</span><span class="n">expr_string</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds a constraint as a string containing</span>
<span class="sd">        an assignment or an inequality, e.g., &#39;a=b&#39; or &#39;a&lt;=b&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">IHasObjectives</span><span class="p">(</span><span class="n">Interface</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An Interface for objects having a multiple objectives.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">add_objectives</span><span class="p">(</span><span class="n">obj_iter</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Takes an iterator of objective strings and creates</span>
<span class="sd">        objectives for them in the driver.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">add_objective</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds an objective to the driver.</span>

<span class="sd">        expr: string</span>
<span class="sd">            String containing the objective expression.</span>
<span class="sd">         &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">remove_objective</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Removes the specified objective expression. Spaces within</span>
<span class="sd">        the expression are ignored.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">clear_objectives</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Removes all objectives.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">eval_objectives</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Returns a list of values of the evaluated objectives.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">get_expr_depends</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Returns a list of tuples of the form (src_comp_name, dest_comp_name)</span>
<span class="sd">        for each dependency introduced by our objectives.</span>
<span class="sd">        &quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">IHasObjective</span><span class="p">(</span><span class="n">IHasObjectives</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An Interface for objects having a single objective.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">eval_objective</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Returns the value of the evaluated objective.&quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">IVariable</span><span class="p">(</span><span class="n">Interface</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">validate</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Validates that the specified value is valid and can be assigned</span>
<span class="sd">        to the data value corresponding to this Variable.</span>
<span class="sd">        &quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">IRepository</span><span class="p">(</span><span class="n">Interface</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An Interface to a version control system repository.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">commit</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Commit any uncommitted changes to the repo.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">revert</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Revert to a previous commit.  Default is to revert to</span>
<span class="sd">        the most recent commit, discarding any uncommitted changes.</span>
<span class="sd">        &quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">IParametricGeometry</span><span class="p">(</span><span class="n">Interface</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An Interface to a parametric geometry model&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">regen_model</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Rebuild the model based on current parameter values.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">list_parameters</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Return a list tuples of input and output parameters and their</span>
<span class="sd">        metadata.  The tuples should be of the form: (name, meta) where</span>
<span class="sd">        meta is a dict.  Two required pieces of metadata are &#39;value&#39;, the</span>
<span class="sd">        current value of the parameter, and &#39;iotype&#39;, which should be &#39;in&#39;</span>
<span class="sd">        for inputs and &#39;out&#39; for outputs.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">set_parameter</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set new value for an input parameter.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">get_parameters</span><span class="p">(</span><span class="n">names</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a list of values for the given list of parameter</span>
<span class="sd">        names.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">register_param_list_changedCB</span><span class="p">(</span><span class="n">callback</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Register a function to be called when the list of parameters</span>
<span class="sd">        changes, e.g., when a new model is loaded or parameters are added</span>
<span class="sd">        or removed.  Note that this function is already defined in the</span>
<span class="sd">        openmdao.main.geom.ParametricGeometry class. If you inherit from that</span>
<span class="sd">        class, you can simply call self.invoke_callbacks() to execute</span>
<span class="sd">        any callbacks that have been registered.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">get_static_geometry</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Return an object that implements the IStaticGeometry interface.</span>
<span class="sd">        &quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">IStaticGeometry</span><span class="p">(</span><span class="n">Interface</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An interface for a geometry object that can be queried and tesselated.</span>
<span class="sd">    These are created by Parametric Geometry objects.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">get_visualization_data</span><span class="p">(</span><span class="n">wv_wrapper</span><span class="p">,</span>  <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Populate the wv_wrapper object with data for faces and edges by</span>
<span class="sd">        calling the following methods on wv_wrapper:</span>

<span class="sd">        set_face_data(points, tris, colors=None, normals=None, name=&#39;&#39;,</span>
<span class="sd">                      bounding_box=None, visible=True, transparency=False,</span>
<span class="sd">                      shading=False, orientation=True, points_visible=False,</span>
<span class="sd">                      lines_visible=False)</span>

<span class="sd">        set_edge_data(points, colors=None,</span>
<span class="sd">                      name=&#39;&#39;, bounding_box=None,</span>
<span class="sd">                      visible=True, transparency=False,</span>
<span class="sd">                      shading=False, orientation=False,</span>
<span class="sd">                      points_visible=False, lines_visible=False)</span>

<span class="sd">        where:</span>

<span class="sd">        points is a float32 1xN*3 ndarray of vertex point coordinates where N is the</span>
<span class="sd">            number of vertices, i.e., [x1,y1,z1,x2,y2,z2,...x_n,y_n,z_n]</span>

<span class="sd">        tris is an int 1xM*3 ndarray of triangle connectivities (vertex indices) where</span>
<span class="sd">            M is the number of triangles.</span>

<span class="sd">        colors is an optional 1x3 float32 ndarray</span>

<span class="sd">        normals is an optional 1xM*3 float32 ndarray where M is the number of triangles</span>

<span class="sd">        For more info, see the WV_Wrapper class definition in _pyV3D.pyx in the pyV3D</span>
<span class="sd">        distribution.</span>

<span class="sd">        &quot;&quot;&quot;</span>


<span class="k">def</span> <span class="nf">obj_has_interface</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="o">*</span><span class="n">ifaces</span><span class="p">):</span>
<div class="viewcode-block" id="obj_has_interface"><a class="viewcode-back" href="../../../srcdocs/packages/openmdao.main.html#openmdao.main.interfaces.obj_has_interface">[docs]</a>    <span class="sd">&quot;&quot;&quot;Returns True if the specified object implements one of the interfaces</span>
<span class="sd">    specified.&quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">iface</span> <span class="ow">in</span> <span class="n">ifaces</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">iface</span><span class="p">,</span> <span class="n">Interface</span><span class="p">)</span> <span class="ow">and</span> <span class="n">iface</span><span class="o">.</span><span class="n">providedBy</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">True</span>
    <span class="k">return</span> <span class="bp">False</span>
</pre></div></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<a href="http://openmdao.org">
 <img src="../../../_static/OpenMDAO_Logo_200w_padded.png"
border="0" alt="OpenMDAO Home"/>
</a>

<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
  <li><a href="http://openmdao.org">OpenMDAO Home</a> &raquo;</li>
  
        <li><a href="../../../index.html">OpenMDAO Documentation v0.8.1</a> &raquo;</li>

          <li><a href="../../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright none.
      Last updated on Aug 26, 2013.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>